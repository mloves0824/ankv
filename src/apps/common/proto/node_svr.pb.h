// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: node_svr.proto

#ifndef PROTOBUF_node_5fsvr_2eproto__INCLUDED
#define PROTOBUF_node_5fsvr_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ankv {
namespace node {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_node_5fsvr_2eproto();
void protobuf_AssignDesc_node_5fsvr_2eproto();
void protobuf_ShutdownFile_node_5fsvr_2eproto();

class Node;
class InfoServerReq;
class InfoServerResp;

enum Type {
  INFOSERVER = 1
};
bool Type_IsValid(int value);
const Type Type_MIN = INFOSERVER;
const Type Type_MAX = INFOSERVER;
const int Type_ARRAYSIZE = Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_descriptor();
inline const ::std::string& Type_Name(Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_descriptor(), value);
}
inline bool Type_Parse(
    const ::std::string& name, Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
enum StatusCode {
  kOk = 0
};
bool StatusCode_IsValid(int value);
const StatusCode StatusCode_MIN = kOk;
const StatusCode StatusCode_MAX = kOk;
const int StatusCode_ARRAYSIZE = StatusCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* StatusCode_descriptor();
inline const ::std::string& StatusCode_Name(StatusCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    StatusCode_descriptor(), value);
}
inline bool StatusCode_Parse(
    const ::std::string& name, StatusCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusCode>(
    StatusCode_descriptor(), name, value);
}
// ===================================================================

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ankv.node.Node)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_node_5fsvr_2eproto();
  friend void protobuf_AssignDesc_node_5fsvr_2eproto();
  friend void protobuf_ShutdownFile_node_5fsvr_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class InfoServerReq : public ::google::protobuf::Message {
 public:
  InfoServerReq();
  virtual ~InfoServerReq();

  InfoServerReq(const InfoServerReq& from);

  inline InfoServerReq& operator=(const InfoServerReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InfoServerReq& default_instance();

  void Swap(InfoServerReq* other);

  // implements Message ----------------------------------------------

  InfoServerReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InfoServerReq& from);
  void MergeFrom(const InfoServerReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // @@protoc_insertion_point(class_scope:ankv.node.InfoServerReq)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* table_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_node_5fsvr_2eproto();
  friend void protobuf_AssignDesc_node_5fsvr_2eproto();
  friend void protobuf_ShutdownFile_node_5fsvr_2eproto();

  void InitAsDefaultInstance();
  static InfoServerReq* default_instance_;
};
// -------------------------------------------------------------------

class InfoServerResp : public ::google::protobuf::Message {
 public:
  InfoServerResp();
  virtual ~InfoServerResp();

  InfoServerResp(const InfoServerResp& from);

  inline InfoServerResp& operator=(const InfoServerResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InfoServerResp& default_instance();

  void Swap(InfoServerResp* other);

  // implements Message ----------------------------------------------

  InfoServerResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InfoServerResp& from);
  void MergeFrom(const InfoServerResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 epoch = 1;
  inline bool has_epoch() const;
  inline void clear_epoch();
  static const int kEpochFieldNumber = 1;
  inline ::google::protobuf::int64 epoch() const;
  inline void set_epoch(::google::protobuf::int64 value);

  // repeated string table_names = 2;
  inline int table_names_size() const;
  inline void clear_table_names();
  static const int kTableNamesFieldNumber = 2;
  inline const ::std::string& table_names(int index) const;
  inline ::std::string* mutable_table_names(int index);
  inline void set_table_names(int index, const ::std::string& value);
  inline void set_table_names(int index, const char* value);
  inline void set_table_names(int index, const char* value, size_t size);
  inline ::std::string* add_table_names();
  inline void add_table_names(const ::std::string& value);
  inline void add_table_names(const char* value);
  inline void add_table_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& table_names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_table_names();

  // required .ankv.node.Node cur_meta = 3;
  inline bool has_cur_meta() const;
  inline void clear_cur_meta();
  static const int kCurMetaFieldNumber = 3;
  inline const ::ankv::node::Node& cur_meta() const;
  inline ::ankv::node::Node* mutable_cur_meta();
  inline ::ankv::node::Node* release_cur_meta();
  inline void set_allocated_cur_meta(::ankv::node::Node* cur_meta);

  // required bool meta_renewing = 4;
  inline bool has_meta_renewing() const;
  inline void clear_meta_renewing();
  static const int kMetaRenewingFieldNumber = 4;
  inline bool meta_renewing() const;
  inline void set_meta_renewing(bool value);

  // @@protoc_insertion_point(class_scope:ankv.node.InfoServerResp)
 private:
  inline void set_has_epoch();
  inline void clear_has_epoch();
  inline void set_has_cur_meta();
  inline void clear_has_cur_meta();
  inline void set_has_meta_renewing();
  inline void clear_has_meta_renewing();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 epoch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> table_names_;
  ::ankv::node::Node* cur_meta_;
  bool meta_renewing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_node_5fsvr_2eproto();
  friend void protobuf_AssignDesc_node_5fsvr_2eproto();
  friend void protobuf_ShutdownFile_node_5fsvr_2eproto();

  void InitAsDefaultInstance();
  static InfoServerResp* default_instance_;
};
// ===================================================================

class InfoServerService_Stub;

class InfoServerService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline InfoServerService() {};
 public:
  virtual ~InfoServerService();

  typedef InfoServerService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void InfoServer(::google::protobuf::RpcController* controller,
                       const ::ankv::node::InfoServerReq* request,
                       ::ankv::node::InfoServerResp* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(InfoServerService);
};

class InfoServerService_Stub : public InfoServerService {
 public:
  InfoServerService_Stub(::google::protobuf::RpcChannel* channel);
  InfoServerService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~InfoServerService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements InfoServerService ------------------------------------------

  void InfoServer(::google::protobuf::RpcController* controller,
                       const ::ankv::node::InfoServerReq* request,
                       ::ankv::node::InfoServerResp* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(InfoServerService_Stub);
};


// ===================================================================


// ===================================================================

// Node

// required string ip = 1;
inline bool Node::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Node::ip() const {
  return *ip_;
}
inline void Node::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Node::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Node::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* Node::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Node::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 port = 2;
inline bool Node::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Node::port() const {
  return port_;
}
inline void Node::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// InfoServerReq

// optional string table_name = 1;
inline bool InfoServerReq::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfoServerReq::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfoServerReq::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfoServerReq::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& InfoServerReq::table_name() const {
  return *table_name_;
}
inline void InfoServerReq::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void InfoServerReq::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void InfoServerReq::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfoServerReq::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* InfoServerReq::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InfoServerReq::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InfoServerResp

// required int64 epoch = 1;
inline bool InfoServerResp::has_epoch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfoServerResp::set_has_epoch() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfoServerResp::clear_has_epoch() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfoServerResp::clear_epoch() {
  epoch_ = GOOGLE_LONGLONG(0);
  clear_has_epoch();
}
inline ::google::protobuf::int64 InfoServerResp::epoch() const {
  return epoch_;
}
inline void InfoServerResp::set_epoch(::google::protobuf::int64 value) {
  set_has_epoch();
  epoch_ = value;
}

// repeated string table_names = 2;
inline int InfoServerResp::table_names_size() const {
  return table_names_.size();
}
inline void InfoServerResp::clear_table_names() {
  table_names_.Clear();
}
inline const ::std::string& InfoServerResp::table_names(int index) const {
  return table_names_.Get(index);
}
inline ::std::string* InfoServerResp::mutable_table_names(int index) {
  return table_names_.Mutable(index);
}
inline void InfoServerResp::set_table_names(int index, const ::std::string& value) {
  table_names_.Mutable(index)->assign(value);
}
inline void InfoServerResp::set_table_names(int index, const char* value) {
  table_names_.Mutable(index)->assign(value);
}
inline void InfoServerResp::set_table_names(int index, const char* value, size_t size) {
  table_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfoServerResp::add_table_names() {
  return table_names_.Add();
}
inline void InfoServerResp::add_table_names(const ::std::string& value) {
  table_names_.Add()->assign(value);
}
inline void InfoServerResp::add_table_names(const char* value) {
  table_names_.Add()->assign(value);
}
inline void InfoServerResp::add_table_names(const char* value, size_t size) {
  table_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InfoServerResp::table_names() const {
  return table_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InfoServerResp::mutable_table_names() {
  return &table_names_;
}

// required .ankv.node.Node cur_meta = 3;
inline bool InfoServerResp::has_cur_meta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InfoServerResp::set_has_cur_meta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InfoServerResp::clear_has_cur_meta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InfoServerResp::clear_cur_meta() {
  if (cur_meta_ != NULL) cur_meta_->::ankv::node::Node::Clear();
  clear_has_cur_meta();
}
inline const ::ankv::node::Node& InfoServerResp::cur_meta() const {
  return cur_meta_ != NULL ? *cur_meta_ : *default_instance_->cur_meta_;
}
inline ::ankv::node::Node* InfoServerResp::mutable_cur_meta() {
  set_has_cur_meta();
  if (cur_meta_ == NULL) cur_meta_ = new ::ankv::node::Node;
  return cur_meta_;
}
inline ::ankv::node::Node* InfoServerResp::release_cur_meta() {
  clear_has_cur_meta();
  ::ankv::node::Node* temp = cur_meta_;
  cur_meta_ = NULL;
  return temp;
}
inline void InfoServerResp::set_allocated_cur_meta(::ankv::node::Node* cur_meta) {
  delete cur_meta_;
  cur_meta_ = cur_meta;
  if (cur_meta) {
    set_has_cur_meta();
  } else {
    clear_has_cur_meta();
  }
}

// required bool meta_renewing = 4;
inline bool InfoServerResp::has_meta_renewing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InfoServerResp::set_has_meta_renewing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InfoServerResp::clear_has_meta_renewing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InfoServerResp::clear_meta_renewing() {
  meta_renewing_ = false;
  clear_has_meta_renewing();
}
inline bool InfoServerResp::meta_renewing() const {
  return meta_renewing_;
}
inline void InfoServerResp::set_meta_renewing(bool value) {
  set_has_meta_renewing();
  meta_renewing_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace node
}  // namespace ankv

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ankv::node::Type>() {
  return ::ankv::node::Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ankv::node::StatusCode>() {
  return ::ankv::node::StatusCode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_node_5fsvr_2eproto__INCLUDED
